<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则及手机数字键盘]]></title>
    <url>%2F2017%2F08%2F04%2F%E6%AD%A3%E5%88%99%E5%8F%8A%E6%89%8B%E6%9C%BA%E6%95%B0%E5%AD%97%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[我有一头小毛驴，可是我从来都不骑 最近在做手机页面时，遇到数字输入的键盘的问题，之前的做法只是一刀切的使用 type=&quot;tel&quot;，不过一直觉得九宫格的电话号码键盘上的英文字母太碍事了。于是想要尝试其它的实现方案，最终的结论却令人沮丧。不过也趁机详细了解了下pattern这个属性。type=&quot;tel&quot; 和 type=&quot;number&quot; 的区别 这里还是先那么先交代一下最初遇到的问题。其实无论是tel还是number都不是完美的： type=”tel” 优点是iOS和Android的键盘表现都差不多 缺点是那些字母好多余，虽然我没有强迫症但还是感觉怪怪的啊。 type=”number” 优点是Android下实现的一个真正的数字键盘 缺点一：iOS下不是九宫格键盘，输入不方便 缺点二：旧版Android（包括微信所用的X5内核）在输入框后面会有超级鸡肋的小尾巴，好在Android 4.4.4以后给去掉了。 不过对于缺点二，我们可以用webkit私有的伪元素给fix掉： 123456input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; appearance: none; margin: 0; &#125; pattern属性pattern用于验证表单输入的内容，通常HTML5的type属性，比如email、tel、number、data类、url等，已经自带了简单的数据格式验证功能了，加上pattern后，前端部分的验证更加简单高效了。 显而易见，pattern的属性值要用正则表达式。 实例 简单的数字验证 数字的验证有两个： 12&lt;input type=&quot;number&quot; pattern=&quot;\d&quot;&gt; &lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot;&gt; 对表单验证来说，这两个正则的作用是一样的，表现的话差异就很大： iOS中，只有[0-9]*才可以调起九宫格数字键盘，\d 无效 Android 4.4以下(包括X5内核)，两者都调起数字键盘； Android 4.4.4以上，只认 type 属性，也就是说，如果上面的代码将 type=”number” 改为 type=”text” ，将调起全键盘而不会是九宫格数字键盘。 常用的正则表达式pattern的用法都一样，这里不再啰嗦各种详细写法了，只是列出来一些常用的正则就好了： 信用卡 [0-9]{13,16} 银联卡 ^62[0-5]\d{13,16}$ Visa: ^4[0-9]{12}(?:[0-9]{3})?$ 万事达：^5[1-5][0-9]{14}$ QQ号码： [1-9][0-9]{4,14} 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 身份证：^([0-9]){7,18}(x|X)?$ 密码：^[a-zA-Z]\w{5,17}$ 字母开头，长度在6~18之间，只能包含字母、数字和下划线 强密码：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间 7个汉字或14个字符：^[\u4e00-\u9fa5]{1,7}$|^[\dA-Za-z_]{1,14}$ 浏览器支持很不幸，pattern的浏览器支持很惨： via Can I Use 但是如果只是如文章开头提到的改数字键盘的话，iOS和Android都是没有问题的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-协同开发]]></title>
    <url>%2F2017%2F08%2F04%2FGit-%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[我有一头小毛驴，可是我从来都不骑 目录 前言 仓库（Repository） 源仓库 开发者仓库 分支（Branch） 永久性分支 暂时性分支 工作流（workflow） 总结 参考资料 前言 （本文假设各位已经对基本git的基本概念、操作有一定的理解，如无相关git知识，可以参考Pro Git这本书进行相关的学习和练习） 很多项目开发都会采用git这一优秀的分布式版本管理工具进行项目版本管理，使用github开源平台作为代码仓库托管平台。由于git的使用非常灵活，在实践当中衍生了很多种不同的工作流程，不同的项目、不同的团队会有不同的协作方式。 本文将介绍一种前人已经在各种大小项目中经过千锤百炼总结出来的一种比较成功的git工作流，这种工作流已经被成功用于许多团队开发当中。掌握git，掌握这种工作流，对大家以后的学习、开发工作大有好处。 先上一张图吓大家一下： 上面一张图展示了一种使用git进行项目协同开发的模式，接下来会进行详细介绍。 仓库（Repository）在项目的开始到结束，我们会有两种仓库。一种是源仓库（origin），一种是开发者仓库。上图中的每个矩形都表示一个仓库，正中间的是我们的源仓库，而其他围绕着源仓库的则是开发者仓库。 源仓库在项目的开始，项目的发起者构建起一个项目的最原始的仓库，我们把它称为origin，例如我们的PingHackers网站，origin就是这个PingHackers/blog了。源仓库的有两个作用： 汇总参与该项目的各个开发者的代码 存放趋于稳定和可发布的代码 源仓库应该是受保护的，开发者不应该直接对其进行开发工作。只有项目管理者（通常是项目发起人）能对其进行较高权限的操作。 开发者仓库上面说过，任何开发者都不会对源仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库的“复制”一份，作为自己日常开发的仓库。这个复制，也就是github上面的fork。 每个开发者所fork的仓库是完全独立的，互不干扰，甚至与源仓库都无关。每个开发者仓库相当于一个源仓库实体的影像，开发者在这个影像中进行编码，提交到自己的仓库中，这样就可以轻易地实现团队成员之间的并行开发工作。而开发工作完成以后，开发者可以向源仓库发送pull request，请求管理员把自己的代码合并到源仓库中，这样就实现了分布式开发工作，和最后的集中式的管理。 分支（Branch）分支是git中非常重要的一个概念，也是git这一个工具中的大杀器，必杀技。在其他集中式版本管理工具（SVN/CVS）把分支定位为高级技巧，而在git中，分支操作则是每个开发人员日常工作流。利用git的分支，可以非常方便地进行开发和测试，如果使用git没有让你感到轻松和愉悦，那是因为你还没有学会使用分支。不把分支用出一点翔来，不要轻易跟别人说你用过git。 在文章开头的那张图中，每一个矩形内部纷繁的枝蔓便是git的分支模型。可以看出，每个开发者的仓库都有自己的分支路线，而这些分支路线会通过代码汇总映射到源仓库中去。 我们为git定下一种分支模型，在这种模型中，分支有两类，五种 永久性分支 master branch：主分支 develop branch：开发分支 临时性分支 feature branch：功能分支 release branch：预发布分支 hotfix branch：bug修复分支 永久性分支永久性分支是寿命无限的分支，存在于整个项目的开始、开发、迭代、终止过程中。永久性分支只有两个master和develop。 master：主分支从项目一开始便存在，它用于存放经过测试，已经完全稳定代码；在项目开发以后的任何时刻当中，master存放的代码应该是可作为产品供用户使用的代码。所以，应该随时保持master仓库代码的清洁和稳定，确保入库之前是通过完全测试和代码reivew的。master分支是所有分支中最不活跃的，大概每个月或每两个月更新一次，每一次master更新的时候都应该用git打上tag，说明你的产品有新版本发布了。 develop：开发分支，一开始从master分支中分离出来，用于开发者存放基本稳定代码。之前说过，每个开发者的仓库相当于源仓库的一个镜像，每个开发者自己的仓库上也有master和develop。开发者把功能做好以后，是存放到自己的develop中，当测试完以后，可以向管理者发起一个pull request，请求把自己仓库的develop分支合并到源仓库的develop中。 所有开发者开发好的功能会在源仓库的develop分支中进行汇总，当develop中的代码经过不断的测试，已经逐渐趋于稳定了，接近产品目标了。这时候，我们就可以把develop分支合并到master分支中，发布一个新版本。所以，一个产品不断完善和发布过程就正如下图： 注意，任何人不应该向master直接进行无意义的合并、提交操作。正常情况下，master只应该接受develop的合并，也就是说，master所有代码更新应该源于合并develop的代码。 暂时性分支暂时性分支和永久性分支不同，暂时性分支在开发过程中是一定会被删除的。所有暂时性分支，一般源于develop，最终也一定会回归合并到develop。 feature：功能性分支，是用于开发项目的功能的分支，是开发者主要战斗阵地。开发者在本地仓库从develop分支分出功能分支，在该分支上进行功能的开发，开发完成以后再合并到develop分支上，这时候功能性分支已经完成任务，可以删除。功能性分支的命名一般为feature-*，*为需要开发的功能的名称。 举一个例子，假设我是一名PingHackers网站的开发者，已经把源仓库fork了，并且clone到了本地。现在要开发PingHackers网站的“讨论”功能。我在本地仓库中可以这样做： step 1: 切换到develop分支 1&gt;&gt;&gt; git checkout develop step 2: 分出一个功能性分支 1&gt;&gt;&gt; git checkout -b feature-discuss step 3: 在功能性分支上进行开发工作，多次commit，测试以后… step 4: 把做好的功能合并到develop中 1&gt;&gt;&gt; git checkout develop # 回到develop分支 &gt;&gt;&gt; git merge --no-ff feature-discuss # 把做好的功能合并到develop中 &gt;&gt;&gt; git branch -d feature-discuss # 删除功能性分支 &gt;&gt;&gt; git push origin develop # 把develop提交到自己的远程仓库中 这样，就完成一次功能的开发和提交。 release：预发布分支，当产品即将发布的时候，要进行最后的调整和测试，这时候就可以分出一个预发布分支，进行最后的bug fix。测试完全以后，发布新版本，就可以把预发布分支删除。预发布分支一般命名为release-*。 hotfix：修复bug分支，当产品已经发布了，突然出现了重大的bug。这时候就要新建一个hotfix分支，继续紧急的bug修复工作，当bug修复完以后，把该分支合并到master和develop以后，就可以把该分支删除。修复bug分支命名一般为hotfix-* release和hotfix分支离我们还比较遥远。。就不详述，有兴趣的同学可以参考本文最后的参考资料进行学习。 工作流（Workflow）啰嗦讲了这么多，概念永远是抽象的。对于新手来说，都喜欢一步一步的步骤傻瓜教程，接下来，我们就一步一步来操作上面所说的工作流程，大家感受一下： Step 1：源仓库的构建这一步通常由项目发起人来操作，我们这里把管理员设为PingHackers，假设PingHackers已经为我们建立起了一个源仓库PingHackers/git-demo，并且已经初始化了两个永久性分支master和develop，如图： Step 2：开发者fork源仓库源仓库建立以后，每个开发就可以去复制一份源仓库到自己的github账号中，然后作为自己开发所用的仓库。假设我是一个项目中的开发者，我就到PingHackers/git-demo项目主页上去fork： fork完以后，我就可以在我自己的仓库列表中看到一个和源仓库一模一样的复制品。这时就应该感叹，你以后要和它相依为命了： Step 3：把自己开发者仓库clone到本地这一步应该不用教，git clone Step 4：构建功能分支进行开发进入仓库中，按照前面说所的构建功能分支的步骤，构建功能分支进行开发、合并，假设我现在要开发一个“讨论”功能： 1&gt;&gt;&gt; git checkout develop # 切换到`develop`分支 &gt;&gt;&gt; git checkout -b feature-discuss # 分出一个功能性分支 &gt;&gt; touch discuss.js # 假装discuss.js就是我们要开发的功能 &gt;&gt; git add . &gt;&gt; git commit -m &apos;finish discuss feature&apos; # 提交更改 &gt;&gt;&gt; git checkout develop # 回到develop分支 &gt;&gt;&gt; git merge --no-ff feature-discuss # 把做好的功能合并到develop中 &gt;&gt;&gt; git branch -d feature-discuss # 删除功能性分支 &gt;&gt;&gt; git push origin develop # 把develop提交到自己的远程仓库中 这时候，你上自己github的项目主页中develop分支中看看，已经有discuss.js这个文件了： Step 5：向管理员提交pull request假设我完成了“讨论”功能（当然，你还可能对自己的develop进行了多次合并，完成了多个功能），经过测试以后，觉得没问题，就可以请求管理员把自己仓库的develop分支合并到源仓库的develop分支中，这就是传说中的pull request。 点击上图的绿色按钮，开发者就可以就可以静静地等待管理员对你的提交的评审了。 Step 6 管理员测试、合并接下来就是管理员的操作了，作为管理员的PingHackers登陆github，便看到了我对源仓库发起的pull request。 这时候PingHackers需要做的事情就是： 对我的代码进行review。github提供非常强大的代码review功能： 在他的本地测试新建一个测试分支，测试我的代码： 1&gt;&gt; git checkout develop # 进入他本地的develop分支 &gt;&gt; git checkout -b livoras-develop # 从develop分支中分出一个叫livoras-develop的测试分支测试我的代码 &gt;&gt; git pull https://github.com/livoras/git-demo.git develop # 把我的代码pull到测试分支中，进行测试 判断是否同意合并到源仓库的develop中，如果经过测试没问题，可以把我的代码合并到源仓库的develop中： 1&gt;&gt; git checkout develop &gt;&gt; git merge --no-ff livoras-develop &gt;&gt; git push origin develop 注意，PingHakers一直在操作的仓库是源仓库。所以我们经过上面一系列操作以后，就可以在源仓库主页中看到： 经过辗转曲折的路程，我们的discuss.js终于从我的开发仓库的功能分支到达了源仓库的develop分支中。以上，就是一个git &amp; github协同工作流的基本步骤。 总结git这一个工具博大精深，很难想象竟然有使用如此恶心而又如此灵活和优雅的工具存在；此又为一神器，大家还是多动手，多查资料，让git成为自己的一项基本技能，帮助自己处理各种项目团队协同工作的问题，成为一个高效的开发者、优秀的项目的管理者。送大家一张神图，好好领悟： 最后给出一些参考资料，供参考学习。 参考资料 A Successful Git Branching Model Understanding the Git Workflow Github flow Pro Git Git分支管理策略]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存]]></title>
    <url>%2F2017%2F07%2F15%2FFirstNight%2F</url>
    <content type="text"><![CDATA[我有一头小毛驴，可是我从来都不骑 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。那么下面我们就来看看服务器端缓存的原理。# 缓存分类web缓存分为很多种，比如数据库缓存、代理服务器缓存、还有我们熟悉的CDN缓存，以及浏览器缓存。对于太多文字的阅读其实我是拒绝的，于是就画了个图来解释下。浏览器通过代理服务器向源服务器发起请求的原理如下图，浏览器先向代理服务器发起Web请求，再将请求转发到源服务器。它属于共享缓存，所以很多地方都可以使用其缓存资源，因此对于节省流量有很大作用。浏览器缓存是将文件保存在客户端，在同一个会话过程中会检查缓存的副本是否足够新，在后退网页时，访问过的资源可以从浏览器缓存中拿出使用。通过减少服务器处理请求的数量，用户将获得更快的体验下面我就来着重讲下传说中的浏览器缓存。# 浏览器缓存页面的缓存状态是由header决定的，header的参数有四种：一、Cache-Control： 1、max-age（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。我们来找个资源看下。比如shang.qq.com上的css资源，max-age=2592000，也就是说缓存有效期为2592000秒（也就是30天）。于是在30天内都会使用这个版本的资源，即使服务器上的资源发生了变化，浏览器也不会得到通知。max-age会覆盖掉Expires，后面会有讨论。 2、s-maxage（单位为s）同max-age，只用于共享缓存（比如CDN缓存）。比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通缓存，而s-maxage用于代理缓存。如果存在s-maxage，则会覆盖掉max-age和Expires header。 3、public 指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public。 4、private 响应只作为私有的缓存（见下图），不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。 5、no-cache 指定不缓存响应，表明资源不进行缓存，比如，但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。 6、no-store 绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存啦～每次请求资源都要从服务器重新获取。 7、must-revalidate指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。二、Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。三、Last-modified 服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。如下图，最后修改时间为2014年12月19日星期五2点50分47秒四、ETag根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下：使用ETag可以解决Last-modified存在的一些问题： a、某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 b、如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒 c、一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。# 使用缓存流程还是用图说话，下面是我所总结的从浏览器请求到展示资源的过程：# cache-control指令使用说了那么多cache-control的指令，那么如何选择使用哪些指令呢？我还是不说话==额外的除了开头提到的那么多缓存方式以外，还有一种我们都熟悉的缓存方式，LocalStorage和sessionStorage（好像是两种23333）。LocalStorage是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；LocalStorage是以页面域名划分的，如果有多个等价域名之间的LocalStorage不互通，则会造成缓存多份浪费。LocalStorage在PC上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用localStorage的速度比不上304。并且不能缓存css文件。而移动端由于网速慢，使用localStorage要快于304。在html中加载一个png图，首次加载的时候时间如下图，然而将图片使用了LocalStorage存储后，再次刷新后加载时间为0。而相对LocalStorage来说，SessionStorage的数据只存储到特定的会话中，不属于持久化的存储，所以关闭浏览器会清除数据。和localstorage具有相同的方法。在前端开发中缓存是必不可少的，那么使用怎样的缓存方式更高效、让我们项目的性能更优，还是需要我们仔细斟酌。 。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>